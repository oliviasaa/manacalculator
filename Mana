import math

################################################################################
##                                                                            ##
##   DEFINITION OF VARIABLES OF THE SYSTEM THAT ARE NOT EXPOSED TO THE USER   ##
##                                                                            ##
################################################################################


iotaSupply = 4292657708000000
slotDuration = 10
slotsInEpoch = 8192
epochDuration = slotsInEpoch*slotDuration
secondsInYear = 60*60*24*365
epochDurationInYears = epochDuration/secondsInYear
betaPerYear = 1/3
generationPerSlot = math.pow(2,-17)
bootstrappingDuration = 1154
rewardsManaShareCoefficient = 2 
RMCLowCongestion = 100000
RMCStableCongestion = 9000000
RMCExtremeCongestion = 500000000

################################################################################
##                                                                            ##
##                           AUXILIARY FUNCTIONS                              ##
##                                                                            ##
################################################################################


# given t in seconds, returns the slot that time t belongs to
def time_to_slot(t):
    slot = int(t/slotDuration)
    return slot

# given t in seconds, returns the epoch that time t belongs to
def time_to_epoch(t):
    epoch = int(t/epochDuration)
    return epoch

# given n in slots, returns the epoch that slot n belongs to
def slot_to_epoch(n):
    epoch = int(n/slotsInEpoch)
    return epoch

# returns the first slot of epoch n
def first_slot_of_epoch(n):
    slot = n*slotsInEpoch
    return slot

# returns the decayed value of value by n epochs
def decay(value, n):
    if value != 0 and n != 0:
        decay = math.exp(-betaPerYear*epochDurationInYears*n)
        value = int(value*decay)
    return value

# returns the potential mana generated by holding value tokens from creationSlot to consumptionSlot
def potential_Mana(value, creationSlot, consumptionSlot, generationRate):
    i = slot_to_epoch(creationSlot)
    j = slot_to_epoch(consumptionSlot)
    n = j-i
    slotAfterEpochi = first_slot_of_epoch(i+1)
    firstSlotEpochJ = first_slot_of_epoch(j)
    d1 = slotAfterEpochi - creationSlot
    d2 = consumptionSlot - firstSlotEpochJ
    if n == 0:
        potentialMana = value*(consumptionSlot-creationSlot)*generationRate     
    elif n == 1:
        potentialMana = value*d2*generationRate + decay(value*d1*generationRate, 1)
    else:
        c = math.exp(-betaPerYear * epochDurationInYears) / (1 - math.exp(-betaPerYear * epochDurationInYears))
        aux = value*generationRate*c*slotsInEpoch
        potentialMana_n = decay(value*d1*generationRate, n)
        potentialMana_n_1 = decay(aux, n-1)
        potentialMana_0 = value*d2*generationRate + aux
        potentialMana = potentialMana_n - potentialMana_n_1 + potentialMana_0
    return potentialMana

# returns the target reward of a certain epoch n 
def targetReward(n):
    finalReward = iotaSupply*rewardsManaShareCoefficient*generationPerSlot*slotsInEpoch
    decayBalancingConstant = math.exp(1)/(bootstrappingDuration*(1-math.exp(-epochDurationInYears*betaPerYear))) 
    initialReward = finalReward * decayBalancingConstant

    if n <= bootstrappingDuration:
        reward = decay(initialReward,n)
    else:
        reward = finalReward
    return reward



################################################################################
##                                                                            ##
##            VARIABLES OF THE SYSTEM THAT ARE EXPOSED TO THE USER            ##
##                          (S/HE CAN CHANGE THEM)                            ##
##                                                                            ##
################################################################################


# note: all validators in this simulation are in the committee. In real life, the committee will
# be composed of the top 32 stakers. In the future, this will be randomized (should we add the randomness to this simulator?)

#number of validators
validators = 3

#tokens in each pool
lockedStake = [100, 100, 100]
delegatedStake = [0, 0, 0]

#historical performance factor of the validators
performance = [1.0, 1.0, 1.0]

#fixed costs of the validators
fixedCosts = [0, 0, 0]

## DEFINITION OF ADDITIONAL ACTOR
yourTokens = 100
yourRole = "Validator" # delegator or validator 
yourPool = 0           # if yourRole = Delegator, this is the pool you are delegating to

if yourRole == "Validator":
    shareOfYourStakeLocked = 1.0
    attractedNewDelegatedStake = 0
    attractedDelegatedStakeFromOtherPools = 0.1
    yourFixedCost = 0
    yourPerformance = 1.0

congestionLevel = "Stable" # low, stable or extreme

## DEFINITION OF TIME FRAME
initialEpoch = 0
finalEpoch = 100
epoch = 1154+1


################################################################################
##                                                                            ##
##                              MAIN CALCULATIONS                             ##
##                                                                            ##
################################################################################

# Combines the info given above (stake of the validators + your stake) into a single vector or stake
if yourRole == "Validator":
    lockedStake.append(yourTokens*shareOfYourStakeLocked)
    fixedCosts.append(yourFixedCost)
    performance.append(yourPerformance)
    delegatedStake.append((1-shareOfYourStakeLocked)*yourTokens+attractedNewDelegatedStake+attractedDelegatedStakeFromOtherPools*sum(delegatedStake))
    for i in range(validators):
        delegatedStake[i] = delegatedStake[i]*(1-attractedDelegatedStakeFromOtherPools)

if yourRole == "Delegator":
    delegatedStake[yourPool] = delegatedStake[yourPool] + yourTokens

totalValidatorsStake = sum(lockedStake)
totalDelegatedStake = sum(delegatedStake)
totalStake = totalDelegatedStake + totalValidatorsStake
restOfTokenHoldings = iotaSupply - totalStake
if restOfTokenHoldings < 0:
    raise ValueError("Pools must have (collectively) at most iotaSupply tokens")

# Calculates profit margin of the epoch (only when there are tokens stake, otherwise, it's set to None)
if totalStake > 0:
    profitMargin = totalValidatorsStake/(totalValidatorsStake+totalStake)
else:
    profitMargin = None

# Calculates the total rewards for each pool, already discounting the validator fixed cost
poolRewards = [0 for i in range(len(lockedStake))]
if totalStake > 0:
    if totalValidatorsStake > 0:
        for i in range(len(lockedStake)):
            poolRewards[i] = ((lockedStake[i]+delegatedStake[i])/totalStake + lockedStake[i]/totalValidatorsStake) * targetReward(epoch) * performance[i]/2.0 - fixedCosts[i]
    else:                
        for i in range(len(lockedStake)):
            poolRewards[i] = ((lockedStake[i]+delegatedStake[i])/totalStake) * targetReward(epoch) * performance[i]/2.0 - fixedCosts[i]

# Calculates the rewards for each validator 
validatorRewards = [0 for i in range(len(lockedStake))]
for i in range(len(lockedStake)):
    if poolRewards[i] < 0:
        validatorRewards[i] = 0
        poolRewards[i] = 0
    elif poolRewards[i] == 0:
        validatorRewards[i] = fixedCosts[i]
    else:
        validatorRewards[i] = fixedCosts[i] + poolRewards[i]*profitMargin + (1-profitMargin)*poolRewards[i]*lockedStake[i]/(delegatedStake[i]+lockedStake[i])

delegatorRewards = [0 for i in range(len(lockedStake))]
for i in range(len(lockedStake)):
    if poolRewards[i] > 0:
        delegatorRewards[i] = poolRewards[i]*(1-profitMargin)*delegatedStake[i]/(delegatedStake[i]+lockedStake[i])

if yourRole == "Delegator":
    if delegatorRewards[yourPool] > 0:
        yourRewards = delegatorRewards[yourPool]*yourTokens/delegatedStake[yourPool]
    else:
        yourRewards = 0

if yourRole == "Validator":
    yourRewards = validatorRewards[-1]

yourPassiveRewards = potential_Mana(yourTokens, first_slot_of_epoch(epoch)-1, first_slot_of_epoch(epoch+1)-1, generationPerSlot)

#print(validatorRewards)
#print(lockedStake)
#print(delegatorRewards)
#print(delegatedStake)
#print(yourPassiveRewards)
#print(yourRewards)
#print(yourTokens)
#print(yourRole)

if congestionLevel == "Low": 
    RMC = RMCLowCongestion
elif congestionLevel == "Stable": 
    RMC = RMCStableCongestion
else:
    RMC = RMCExtremeCongestion

yourBlocksPerEpoch = yourPassiveRewards/RMC
yourAdditionalBlocksPerEpoch = yourRewards/RMC

yourTPS = yourBlocksPerEpoch/epochDuration
yourAdditionalTPS = yourAdditionalBlocksPerEpoch/epochDuration

print(yourTPS)
print(yourAdditionalTPS)
